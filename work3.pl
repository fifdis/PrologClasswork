%% списки - рекурсивная структура, состоящая из двух частей
%% состав - голова и хвост
%% хвост - всегда список
%% голова - элемент списка (первый!) 

%% [1, 2, 3, 4, 5]  - пример списка, если мы знаем количество элементов
%% ['1', '2', '3']
%% в прологе (чаще всего) нет ограничений на типы, т.е. в одном списке
%% могут быть элементы разных типов

%% базис рекурсии для списка - пустой список: []

%%  [1, 2, 3, 4, 5] = [1| [2, 3, 4, 5]] = [1| [2| [3, 4, 5]]] =
%% = [1| [2| [3| [4, 5]]]] = [1| [2| [3| [4| [5|[]]]]]] =
%% [1, 2, 3| [4, 5]]
%% разделение между головой и хвостом осуществляется вертикальной чертой
%% в списке мы всегда можем выделить то необходимое количество элементов,
%% которое нам нужно для головы

%% пример: вычисление длины строки
l_length([], 0). %% здесь - длина пустого списка равна 0
l_length([_|T], LL) :- l_length(T, TL), LL is TL+1.

%% можно собрать элементы: X=[1,2,3], Y=8, B=[Y|X]
%% на выходе получится B=[8,1,2,3]

%% если X=[1,2,3], Y=[4,5], B=[X|Y]
%% то B=[[1,2,3],4,5] - получится список из 3 элементов, т.к. голова является списком

%% пример: конкатенация строк

%% нужно учитывать случаи, когда один из двух списков произвольный, второй - пустой
%% L1 + L2
%% [H1|T1] + L2 = [H1|T1+L2]

l_concat([], L, L).
l_concat([H|T], L, [H|TL]):-l_concat(T, L, TL).

%% проверка: l_concat([1,2,3],[4,5],R).
%% R = [1, 2, 3, 4, 5].

%% проверка, является ли список в последнем параметре конкатенацией 2х первых
%% l_concat([1,2,3],[4,5],[2,3,3,4,5]).
%% false.

%% и т.д., предикаты работают в любую сторону 

%% вычисление длины с хвостовой рекурсией
l_lengthT_U(S, L):-l_lengthT(S, 0, L).
l_lengthT([], R, R) :- !.
l_lengthT([_|T], R, L):- R1 is R+1, l_lengthT(T, R1, L).

%% конкатенация с хвостовой рекурсией 
l_concatT([H1|T1], S2, Res, Acc1):-l_concatT(T1, S2, Res, [H1|Acc1]).
l_concatT([], [H2|S2], Res, [HA|Acc1]):- l_concatT([], [HA,H2|S2], Res, Acc1).
l_concatT([], Res, Res, []).

%% реверсия списка
l_rev([], []):-!.
l_rev([H|T], LR):- l_rev(T, TR), l_concat(TR, [H], LR).

%% если список большой, то Prolog будет выводить '...'
%% в таком случае в конце следует добавлять repeat

l_reverse([], Res, Res).
l_reverse([H|T], Acc, Res):-l_reverse(T, [H|Acc], Res).

%% генерация списка по числу (задаем N и получаем список от N до 1)
l_generate(0, []):-!.
l_generate(1, [1]):-!.
l_generate(N, [N|T]):- N1 is N-1, l_generate(N1, T).

%% генерация списка по числу (задаем N и получаем список от 1 до N)
l_generate2U(N, S):-l_generate2(1, N, S).
l_generate2(Cur, N, [Cur|T]):- Cur=<N, Next is Cur+1, l_generate2(Next, N, T).
l_generate2(Cur, N, []):- Cur>N, !.

%% генерация списка [1, N] с хвостовой рекурсией
lgenT_U(N, T) :- lgenT(N, [], T).
lgenT(0, Acc, Acc):-!.
lgenT(N, Acc, S):- N1 is N-1, lgenT(N1, [N|Acc], S).

%% генерация списка [N, 1] с хвостовой рекурсией
lgenT2_U(N, T) :- lgenT2(1, N, [], T).
lgenT2(Cur, N, Acc, T):- Cur =< N, Acc2 = [Cur|Acc], Next is Cur+1, lgenT2(Next, N, Acc2, T).
lgenT2(Cur, N, Acc, Acc):-Cur>N.

%% сумма двух списков, вне зависимости от их длинны
lsum([], [], []) :- !.
lsum(S1, [], S1) :- !.
lsum([], S2, S2) :- !.
lsum([H1|T1], [H2|T2], [S|R]) :- S is H1+H2, lsum(T1, T2, R). 

%% сумма двух списков, вне зависимости от их длины, хвостовая рекурсия
%% -...-


%% список заданной длины со случайными числами из заданного диапазона
minmax(X1, X2, Min, Max):- X1 > X2, !, Min is X2, Max is X1.
minmax(X1, X2, Min, Max):- Min is X1, Max is X2.
random_list(0, _, _, []).
random_list(L, X1, X2, [Num|T]) :- L>0, minmax(X1, X2, Min, Max), random(Min, Max, Num), L1 is L-1, random_list(L1, X1, X2, T).

%% усложненная версия программы выше:
%% генерируем список до тех пор, пока x < M
%% (переделать)
checknum(Num, M, T) :- Num =< M, !, random_list2(N, M, T).
random_list2(N, M, [Num|T]) :- Num is random(N), checknum(Num, M, T).
random_list2(N, M, []).